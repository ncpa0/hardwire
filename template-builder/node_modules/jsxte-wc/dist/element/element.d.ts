import { EventEmitter } from "../utils/event-emitter";
import { OnSlotChangeCallback } from "./decorator-slotted";
import { SlotAttributeChangeEvent, SlotContentChangeEvent, WcSlot } from "./slot";
export type Dependency<T> = {
    getValue: () => T;
    name: string;
};
export type Effect = {
    isFirstMount: boolean;
};
export declare abstract class Element extends HTMLElement {
    private _vroot?;
    private _root;
    private _requestBatch;
    private _attributeObserver;
    private _attributeController;
    private _observedAttributes;
    private _isObservingSlots;
    private _slotChangeListeners;
    private _isConnected;
    private _dependencySelector;
    lifecycle: EventEmitter;
    constructor();
    private _performFirstMount;
    private _preformNextUpdate;
    private _updateDom;
    private _handleObserverEvent;
    private _handleContentMutation;
    connectToWcSlot(node: WcSlot): void;
    disconnectFromWcSlot(node: WcSlot): void;
    handleSlotContentChange: (event: SlotContentChangeEvent) => void;
    handleSlotAttributeChange: (event: SlotAttributeChangeEvent) => void;
    observeAttribute(attributeName: string): void;
    observeSlots(listener: OnSlotChangeCallback): void;
    requestUpdate(): void;
    connectedCallback(): void;
    disconnectedCallback(): void;
    /**
     * Registers a callback that will be ran on every change of the
     * specified dependencies (attribute or state) and after first
     * mount.
     *
     * This effect always happens after the DOM has been updated.
     *
     * @returns A `stop` function that cancels the effect.
     */
    effect<E extends Element>(this: E, cb: (effect: Effect) => void | (() => void), getDependencies: (select: {
        [K in keyof Omit<E, keyof Element | "render">]: Dependency<E[K]>;
    }) => Dependency<any>[] | void): () => void;
    /**
     * Registers a callback that will be ran on every change of the
     * specified dependencies (attribute or state) and before first
     * mount.
     *
     * This effect always happens right before the render, meaning that
     * state and attribute changes within it will affect the subsequent
     * render result and won't trigger another re-render.
     *
     * @returns A `stop` function that cancels the effect.
     */
    immediateEffect<E extends Element>(this: E, cb: (effect: Effect) => void | (() => void), getDependencies: (select: {
        [K in keyof Omit<E, keyof Element | "render">]: Dependency<E[K]>;
    }) => Dependency<any>[] | void): () => void;
    protected abstract render(): JSX.Element;
    /**
     * Override this method to add additional class names to the root
     * element.
     *
     * @returns An array of class names (string[])
     */
    getRootClassNames?(): string[];
}
