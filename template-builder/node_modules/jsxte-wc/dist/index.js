var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/utils/array-map.ts
var ArrayMap = class {
  static {
    __name(this, "ArrayMap");
  }
  entries = [];
  get size() {
    return this.entries.length;
  }
  at(index) {
    return this.entries[index]?.slice();
  }
  set(key, value) {
    const index = this.entries.findIndex(([k]) => k === key);
    if (index === -1) {
      this.entries.push([key, value]);
    } else {
      this.entries[index] = [key, value];
    }
  }
  get(key) {
    const entry = this.entries.find(([k]) => k === key);
    return entry?.[1];
  }
  has(key) {
    return this.entries.some(([k]) => k === key);
  }
  clear() {
    this.entries = [];
  }
  delete(key) {
    const index = this.entries.findIndex(([k]) => k === key);
    if (index === -1)
      return false;
    this.entries.splice(index, 1);
    return true;
  }
  keys() {
    return this.entries.map(([k]) => k);
  }
  values() {
    return this.entries.map(([, v]) => v);
  }
  forEach(cb) {
    for (let i = 0; i < this.entries.length; i++) {
      const [key, value] = this.entries[i];
      cb(value, key);
    }
  }
};

// src/element/element-events.ts
var ElementLifecycleEvent = /* @__PURE__ */ ((ElementLifecycleEvent2) => {
  ElementLifecycleEvent2["WillUpdate"] = "element-will-update";
  ElementLifecycleEvent2["DidUpdate"] = "element-did-update";
  ElementLifecycleEvent2["WillMount"] = "element-will-mount";
  ElementLifecycleEvent2["DidMount"] = "element-did-mount";
  ElementLifecycleEvent2["DidUnmount"] = "element-did-unmount";
  ElementLifecycleEvent2["SlotDidChange"] = "element-slot-did-change";
  ElementLifecycleEvent2["StateDidChange"] = "element-state-did-change";
  ElementLifecycleEvent2["AttributeDidChange"] = "element-attribute-did-change";
  return ElementLifecycleEvent2;
})(ElementLifecycleEvent || {});
var ElementWillUpdateEvent = class extends CustomEvent {
  static {
    __name(this, "ElementWillUpdateEvent");
  }
  constructor() {
    super("element-will-update" /* WillUpdate */);
  }
};
var ElementDidUpdateEvent = class extends CustomEvent {
  static {
    __name(this, "ElementDidUpdateEvent");
  }
  constructor() {
    super("element-did-update" /* DidUpdate */);
  }
};
var ElementWillMountEvent = class extends CustomEvent {
  static {
    __name(this, "ElementWillMountEvent");
  }
  constructor() {
    super("element-will-mount" /* WillMount */);
  }
};
var ElementDidMountEvent = class extends CustomEvent {
  static {
    __name(this, "ElementDidMountEvent");
  }
  constructor() {
    super("element-did-mount" /* DidMount */);
  }
};
var ElementDidUnmountEvent = class extends CustomEvent {
  static {
    __name(this, "ElementDidUnmountEvent");
  }
  constructor() {
    super("element-did-unmount" /* DidUnmount */);
  }
};
var ElementSlotDidChangeEvent = class extends CustomEvent {
  static {
    __name(this, "ElementSlotDidChangeEvent");
  }
  constructor(slotName, changes) {
    super("element-slot-did-change" /* SlotDidChange */, {
      detail: {
        slotName,
        changes
      }
    });
  }
};
var ElementStateDidChangeEvent = class extends CustomEvent {
  static {
    __name(this, "ElementStateDidChangeEvent");
  }
  constructor(stateName, prevValue, newValue) {
    super("element-state-did-change" /* StateDidChange */, {
      detail: {
        stateName,
        prevValue,
        newValue
      }
    });
  }
};
var ElementAttributeDidChangeEvent = class extends CustomEvent {
  static {
    __name(this, "ElementAttributeDidChangeEvent");
  }
  constructor(attributeName, prevValue, newValue) {
    super("element-attribute-did-change" /* AttributeDidChange */, {
      detail: {
        attributeName,
        prevValue,
        newValue
      }
    });
  }
};

// src/element/attribute-controller.ts
var Attribute = class {
  constructor(name, parser) {
    this.name = name;
    this.parser = parser;
  }
  static {
    __name(this, "Attribute");
  }
  current = null;
  onChange = null;
  onSet = null;
  get() {
    return this.current;
  }
  setInternal(v) {
    this.current = v;
  }
  set(v) {
    const newValue = v;
    if (!Object.is(this.current, newValue)) {
      const prevValue = this.current;
      this.current = newValue;
      this.onChange?.(newValue, prevValue);
      this.onSet?.();
    }
  }
  isEqualTo(v) {
    return Object.is(this.current, v);
  }
  isEqualToRaw(v) {
    return Object.is(this.current, this.parser(v));
  }
  syncDown(element) {
    const v = element.getAttribute(this.name);
    const newValue = this.parser(v);
    if (!Object.is(this.current, newValue)) {
      const prevValue = this.current;
      this.current = newValue;
      this.onChange?.(newValue, prevValue);
    }
  }
  syncUp(element) {
    if (this.current === null) {
      element.removeAttribute(this.name);
    } else {
      element.setAttribute(this.name, String(this.current));
    }
  }
};
var AttributeController = class {
  constructor(element) {
    this.element = element;
  }
  static {
    __name(this, "AttributeController");
  }
  attributes = new ArrayMap();
  registerAttribute(attribute) {
    this.attributes.set(attribute.name, attribute);
    this.element.observeAttribute(attribute.name);
    attribute.onChange = (newValue, prevValue) => {
      this.element.requestUpdate();
      this.element.lifecycle.dispatchEvent(
        new ElementAttributeDidChangeEvent(
          attribute.name,
          prevValue,
          newValue
        )
      );
    };
    attribute.onSet = () => {
      attribute.syncUp(this.element);
    };
  }
  getAttribute(name) {
    return this.attributes.get(name);
  }
  detectedPossibleChange(mutation) {
    const attribute = this.attributes.get(mutation.attributeName);
    if (attribute) {
      attribute.syncDown(this.element);
    }
  }
  syncUpAll() {
    this.attributes.forEach((attribute) => {
      attribute.syncUp(this.element);
    });
  }
};

// src/element/decorator-attribute.ts
function nullableNumberParser(value) {
  return value === null ? null : Number(value);
}
__name(nullableNumberParser, "nullableNumberParser");
function nonNullableNumberParser(value, defaultValue = 0) {
  return value === null ? defaultValue : Number(value);
}
__name(nonNullableNumberParser, "nonNullableNumberParser");
function nullableStringParser(value) {
  return value;
}
__name(nullableStringParser, "nullableStringParser");
function nonNullableStringParser(value, defaultValue = "") {
  return value === null ? defaultValue : value;
}
__name(nonNullableStringParser, "nonNullableStringParser");
function nullableBooleanParser(attributeName, value) {
  switch (value) {
    case "":
    case "true":
      return true;
    case "false":
      return false;
  }
  if (typeof value === "string") {
    return value === attributeName;
  }
  return null;
}
__name(nullableBooleanParser, "nullableBooleanParser");
function nonNullableBooleanParser(attributeName, value, defaultValue = false) {
  switch (value) {
    case "":
    case "true":
      return true;
    case "false":
      return false;
  }
  return value === attributeName ? true : defaultValue;
}
__name(nonNullableBooleanParser, "nonNullableBooleanParser");
function attribValueParserFactory(attributeName, opts) {
  const { nullable = false } = opts;
  switch (opts.type) {
    case "number":
      if (nullable) {
        return nullableNumberParser;
      }
      return (v) => nonNullableNumberParser(v, opts.default);
    case "boolean":
      if (nullable) {
        return (v) => nullableBooleanParser(attributeName, v);
      }
      return (v) => nonNullableBooleanParser(
        attributeName,
        v,
        opts.default
      );
  }
  if (nullable) {
    return nullableStringParser;
  }
  return (v) => nonNullableStringParser(v, opts.default);
}
__name(attribValueParserFactory, "attribValueParserFactory");
function Attribute2(opts = {}) {
  return (accessor, context) => {
    const attributeName = (opts.name ?? context.name).toLowerCase();
    const valueParser = attribValueParserFactory(
      attributeName,
      opts
    );
    return {
      get() {
        return this["_attributeController"].getAttribute(attributeName)?.get();
      },
      set(value) {
        this["_attributeController"].getAttribute(attributeName)?.set(value);
      },
      init(value) {
        const attr = new Attribute(attributeName, valueParser);
        this["_attributeController"].registerAttribute(attr);
        const htmlValue = this.getAttribute(attributeName);
        if (htmlValue !== null) {
          attr.setInternal(valueParser(htmlValue));
        } else {
          attr.setInternal(value == null ? valueParser(null) : value);
        }
        this.lifecycle.on("element-will-mount" /* WillMount */, () => {
          const htmlValue2 = this.getAttribute(attributeName);
          if (!attr.isEqualToRaw(htmlValue2)) {
            attr.setInternal(valueParser(htmlValue2));
          }
        });
        return attr.get();
      }
    };
  };
}
__name(Attribute2, "Attribute");

// src/element/decorator-custom-element.ts
function CustomElement(tagName) {
  return (target, _) => {
    customElements.define(tagName, target);
  };
}
__name(CustomElement, "CustomElement");

// src/element/slot.ts
var SlotAttributeChangeEvent = class extends CustomEvent {
  static {
    __name(this, "SlotAttributeChangeEvent");
  }
  constructor(node) {
    super("slotattributechange", {
      bubbles: true,
      cancelable: true,
      detail: { node }
    });
  }
};
var SlotContentChangeEvent = class extends CustomEvent {
  static {
    __name(this, "SlotContentChangeEvent");
  }
  constructor(node) {
    super("slotcontentchange", {
      bubbles: true,
      cancelable: true,
      detail: { node }
    });
  }
};
var WcSlot = class extends HTMLElement {
  static {
    __name(this, "WcSlot");
  }
  _isWcSlot = true;
  static isSlot(elem) {
    return elem._isWcSlot === true;
  }
  _observer = new MutationObserver(
    (a) => this._handleObserverEvent(a)
  );
  emitter = new EventTarget();
  constructor() {
    super();
  }
  _handleObserverEvent(mutations) {
    if (this.shouldEmitAttributeChangeEvent(mutations)) {
      this.emitter.dispatchEvent(new SlotAttributeChangeEvent(this));
    }
    if (this.shouldEmitContentChangeEvent(mutations)) {
      this.emitter.dispatchEvent(new SlotContentChangeEvent(this));
    }
  }
  shouldEmitAttributeChangeEvent(mutations) {
    for (let i = 0; i < mutations.length; i++) {
      const mutation = mutations[i];
      if (mutation.type === "attributes" && mutation.attributeName && mutation.oldValue !== this.getAttribute(mutation.attributeName)) {
        return true;
      }
    }
    return false;
  }
  shouldEmitContentChangeEvent(mutations) {
    for (let i = 0; i < mutations.length; i++) {
      const mutation = mutations[i];
      if (mutation.type === "childList" || mutation.type === "characterData") {
        return true;
      }
    }
    return false;
  }
  connectedCallback() {
    this.style.display = "none";
    this._observer.observe(this, {
      attributes: true,
      characterData: true,
      childList: true,
      subtree: true,
      attributeOldValue: true
    });
  }
  disconnectedCallback() {
    this._observer.disconnect();
  }
};

// src/element/decorator-slotted.ts
var defaultShouldUpdate = /* @__PURE__ */ __name((current, changes) => {
  return changes.added.length > 0 || changes.removed.length > 0 || changes.contentChanged.length > 0 || changes.attributeChanged.length > 0;
}, "defaultShouldUpdate");
function Slotted(opts = {}) {
  return (accessor, context) => {
    const { filter: optFilter } = opts;
    let filter = /* @__PURE__ */ __name(() => true, "filter");
    switch (typeof optFilter) {
      case "string":
        filter = /* @__PURE__ */ __name((elem) => elem.matches(optFilter), "filter");
        break;
      case "function":
        filter = optFilter;
        break;
    }
    const { shouldRequestUpdate = defaultShouldUpdate } = opts;
    const updateSlots = /* @__PURE__ */ __name((elem, changes) => {
      let current = accessor.get.call(elem).slice();
      const shouldAdd = changes.added.filter(filter);
      const shouldRemove = changes.removed;
      const added = [];
      const removed = [];
      const contentChanged = [];
      const attributeChanged = [];
      for (let i = 0; i < changes.attributeChanged.length; i++) {
        const slot = changes.attributeChanged[i];
        if (filter(slot)) {
          const idx = current.indexOf(slot);
          if (idx === -1) {
            current.push(slot);
            added.push(slot);
          } else {
            attributeChanged.push(slot);
          }
        } else {
          const idx = current.indexOf(shouldRemove[i]);
          if (idx !== -1) {
            current.splice(idx, 1);
            removed.push(slot);
          }
        }
      }
      for (let i = 0; i < changes.contentChanged.length; i++) {
        const slot = changes.contentChanged[i];
        if (filter(slot)) {
          const idx = current.indexOf(slot);
          if (idx === -1) {
            current.push(slot);
            added.push(slot);
          } else {
            contentChanged.push(slot);
          }
        } else {
          const idx = current.indexOf(shouldRemove[i]);
          if (idx !== -1) {
            current.splice(idx, 1);
            removed.push(slot);
          }
        }
      }
      for (let i = 0; i < shouldRemove.length; i++) {
        const idx = current.indexOf(shouldRemove[i]);
        if (idx !== -1) {
          current.splice(idx, 1);
          removed.push(shouldRemove[i]);
        }
      }
      for (let i = 0; i < shouldAdd.length; i++) {
        const slot = shouldAdd[i];
        const idx = current.indexOf(slot);
        if (idx === -1) {
          current.push(slot);
          added.push(slot);
        }
      }
      accessor.set.call(elem, current);
      const finalChanges = {
        added,
        removed,
        contentChanged,
        attributeChanged
      };
      return finalChanges;
    }, "updateSlots");
    context.addInitializer(function() {
      this.observeSlots((changes) => {
        const finalChanges = updateSlots(this, changes);
        if (shouldRequestUpdate(accessor.get.call(this), finalChanges)) {
          this.requestUpdate();
        }
        this.lifecycle.dispatchEvent(
          new ElementSlotDidChangeEvent(
            context.name,
            finalChanges
          )
        );
      });
      this.lifecycle.once("element-did-mount" /* DidMount */, () => {
        const children = Array.from(this.children);
        const initValue = [];
        for (let i = 0; i < children.length; i++) {
          const elem = children[i];
          if (WcSlot.isSlot(elem) && filter(elem)) {
            initValue.push(elem);
            this.connectToWcSlot(elem);
          }
        }
        accessor.set.call(this, initValue);
        const finalChanges = {
          added: initValue,
          attributeChanged: [],
          contentChanged: [],
          removed: []
        };
        if (shouldRequestUpdate(accessor.get.call(this), finalChanges)) {
          this.requestUpdate();
        }
        this.lifecycle.dispatchEvent(
          new ElementSlotDidChangeEvent(
            context.name,
            finalChanges
          )
        );
      });
    });
    return {
      set() {
      },
      get() {
        return accessor.get.call(this);
      },
      init() {
        return [];
      }
    };
  };
}
__name(Slotted, "Slotted");

// src/element/decorator-state.ts
function State() {
  return (accessor, context) => {
    return {
      get() {
        return accessor.get.call(this);
      },
      set(value) {
        const prevValue = accessor.get.call(this);
        if (!Object.is(prevValue, value)) {
          accessor.set.call(this, value);
          this.requestUpdate();
          this.lifecycle.dispatchEvent(
            new ElementStateDidChangeEvent(
              context.name,
              prevValue,
              value
            )
          );
        }
      }
    };
  };
}
__name(State, "State");

// src/element/element.ts
import { renderToJson } from "jsxte";

// src/utils/event-emitter.ts
var EventEmitter = class extends EventTarget {
  static {
    __name(this, "EventEmitter");
  }
  once(type, listener, capture) {
    super.addEventListener(type, listener, {
      once: true,
      capture
    });
  }
  on(type, listener, capture) {
    super.addEventListener(type, listener, {
      capture
    });
  }
  off(type, listener) {
    super.removeEventListener(type, listener);
  }
  addEventListener(type, listener, capture) {
    super.addEventListener(type, listener, {
      capture
    });
  }
  removeEventListener(type, listener) {
    super.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    return super.dispatchEvent(event);
  }
};

// src/utils/expand-fragments.ts
function expandFragments(elements) {
  let expandedElements = [];
  for (let i = 0; i < elements.length; i++) {
    const element = elements[i];
    if (typeof element === "string") {
      expandedElements.push(element);
      continue;
    }
    if (element.element === "") {
      expandedElements = expandedElements.concat(
        expandFragments(element.children)
      );
      continue;
    }
    expandedElements.push(element);
  }
  return expandedElements;
}
__name(expandFragments, "expandFragments");

// src/vdom/attribute-setter.ts
function attributeSetterFactory(element, attr) {
  if (attr.startsWith("on")) {
    let lastValue = void 0;
    return (value) => {
      if (value === lastValue)
        return;
      const eventName = attr.slice(2).toLowerCase();
      if (lastValue) {
        element.removeEventListener(eventName, lastValue);
      }
      element.addEventListener(eventName, value);
      lastValue = value;
    };
  } else if (attr === "value" && "value" in element) {
    let lastValue = attr[1];
    return (value) => {
      if (value === lastValue)
        return;
      lastValue = value;
      if (value == null || value === false) {
        element.removeAttribute(attr);
        element.value = "";
      } else {
        element.setAttribute(attr, value);
        element.value = value;
      }
    };
  } else {
    let lastValue = attr[1];
    return (value) => {
      if (value === lastValue)
        return;
      lastValue = value;
      if (value == null || value === false) {
        element.removeAttribute(attr);
      } else {
        element.setAttribute(attr, value);
      }
    };
  }
}
__name(attributeSetterFactory, "attributeSetterFactory");

// src/vdom/virtual-text-node.ts
var VirtualTextNode = class {
  constructor(text) {
    this.text = text;
    this.element.textContent = text;
  }
  static {
    __name(this, "VirtualTextNode");
  }
  elementName = "text-node";
  element = document.createTextNode("");
  update(text) {
    if (text === this.text)
      return;
    this.text = text;
    this.element.textContent = text;
  }
  cleanup() {
  }
};

// src/vdom/virtual-element.ts
var VirtualElement = class _VirtualElement {
  static {
    __name(this, "VirtualElement");
  }
  static createVirtual(elemJson) {
    switch (typeof elemJson) {
      case "string":
        return new VirtualTextNode(elemJson);
      case "object":
        return new _VirtualElement(elemJson);
    }
  }
  static createFor(name, element) {
    const instance = Object.setPrototypeOf(
      {
        elementName: name,
        element,
        lastUpdatedAttributes: [],
        children: [],
        attributes: new ArrayMap()
      },
      _VirtualElement.prototype
    );
    return instance;
  }
  elementName;
  element;
  ref;
  lastUpdatedAttributes = [];
  children = [];
  attributes = new ArrayMap();
  constructor(elemJson) {
    this.elementName = elemJson.element;
    this.element = document.createElement(this.elementName);
    this.updateAttributes(elemJson.attributes);
    this.updateChildren(elemJson.children);
  }
  setAttribute(attr) {
    let setter = this.attributes.get(attr[0]);
    if (!setter) {
      setter = attributeSetterFactory(this.element, attr[0]);
      this.attributes.set(attr[0], setter);
    }
    setter(attr[1]);
  }
  updateAttributes(attributes) {
    const updatedAttributes = [];
    for (let i = 0; i < attributes.length; i++) {
      const attribute = attributes[i];
      if (attribute[0] === "ref") {
        const ref = attribute[1];
        ref.current = this.element;
        this.ref = ref;
        continue;
      }
      this.setAttribute(attribute);
      updatedAttributes.push(attribute[0]);
    }
    for (let i = 0; i < this.lastUpdatedAttributes.length; i++) {
      const attributeName = this.lastUpdatedAttributes[i];
      if (!updatedAttributes.includes(attributeName)) {
        const attrSetter = this.attributes.get(attributeName);
        attrSetter(void 0);
      }
    }
    this.lastUpdatedAttributes = updatedAttributes;
  }
  updateChildren(children) {
    children = expandFragments(children);
    if (this.children.length > children.length) {
      for (let i = children.length; i < this.children.length; i++) {
        const child = this.children[i];
        this.element.removeChild(child.element);
        child.cleanup();
      }
      this.children.splice(children.length);
    }
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      const prevChild = this.children[i];
      if (!prevChild) {
        const newChild = _VirtualElement.createVirtual(child);
        this.children[i] = newChild;
        this.element.appendChild(newChild.element);
        continue;
      }
      if (typeof child === "string") {
        if (prevChild.elementName === "text-node") {
          prevChild.update(child);
        } else {
          const newChild = new VirtualTextNode(child);
          this.children[i] = newChild;
          this.element.replaceChild(
            newChild.element,
            prevChild.element
          );
        }
      } else {
        if (prevChild.elementName === child.element) {
          prevChild.update(child);
        } else {
          const newChild = new _VirtualElement(child);
          this.children[i] = newChild;
          this.element.replaceChild(
            newChild.element,
            prevChild.element
          );
        }
      }
    }
  }
  getChildElements() {
    const result = [];
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      result.push(child.element);
    }
    return result;
  }
  update(elemJson) {
    this.updateAttributes(elemJson.attributes);
    this.updateChildren(elemJson.children);
  }
  cleanup() {
    if (this.ref) {
      this.ref.current = null;
    }
    for (let i = 0; i < this.children.length; i++) {
      this.children[i].cleanup();
    }
  }
};

// src/element/request-batch.ts
var RequestBatch = class {
  constructor(callback) {
    this.callback = callback;
  }
  static {
    __name(this, "RequestBatch");
  }
  status = "idle";
  request() {
    if (this.status === "waiting") {
      return;
    }
    this.status = "waiting";
    queueMicrotask(() => {
      let runAfter;
      try {
        runAfter = this.callback();
      } finally {
        this.status = "idle";
        runAfter?.();
      }
    });
  }
};

// src/element/element.ts
var noop = /* @__PURE__ */ __name(() => {
}, "noop");
var createRoot = /* @__PURE__ */ __name((element) => {
  const root = document.createElement("div");
  root.style.display = "contents";
  const additionalClassNames = element.getRootClassNames?.() ?? [];
  root.classList.add("wc-root", ...additionalClassNames);
  return root;
}, "createRoot");
var Element = class extends HTMLElement {
  static {
    __name(this, "Element");
  }
  _vroot;
  _root = createRoot(this);
  _requestBatch = new RequestBatch(() => this._updateDom());
  _attributeObserver = new MutationObserver(
    (a) => this._handleObserverEvent(a)
  );
  _attributeController = new AttributeController(this);
  _observedAttributes = [];
  _isObservingSlots = false;
  _slotChangeListeners = [];
  _isConnected = false;
  _dependencySelector = new Proxy(
    {},
    {
      get: (_, prop) => {
        return {
          getValue: () => this[prop],
          name: prop
        };
      }
    }
  );
  lifecycle = new EventEmitter();
  constructor() {
    super();
  }
  _performFirstMount() {
    this.lifecycle.dispatchEvent(new ElementWillMountEvent());
    this._attributeController.syncUpAll();
    const jsxElem = this.render();
    const json = renderToJson(jsxElem);
    this._vroot = VirtualElement.createFor("<root>", this._root);
    this._vroot.updateChildren([json]);
    return () => this.lifecycle.dispatchEvent(new ElementDidMountEvent());
  }
  _preformNextUpdate() {
    this.lifecycle.dispatchEvent(new ElementWillUpdateEvent());
    const jsxElem = this.render();
    const json = renderToJson(jsxElem);
    this._vroot.updateChildren([json]);
    return () => this.lifecycle.dispatchEvent(new ElementDidUpdateEvent());
  }
  _updateDom() {
    if (this._vroot) {
      return this._preformNextUpdate();
    } else {
      return this._performFirstMount();
    }
  }
  _handleObserverEvent(mutationRecord) {
    for (let i = 0; i < mutationRecord.length; i++) {
      const record = mutationRecord[i];
      if (record.attributeName) {
        this._attributeController.detectedPossibleChange(record);
      } else if (record.type === "childList") {
        this._handleContentMutation(record);
      }
    }
  }
  _handleContentMutation(record) {
    const added = [];
    const removed = [];
    for (let j = 0; j < record.addedNodes.length; j++) {
      const node = record.addedNodes[j];
      if (WcSlot.isSlot(node)) {
        added.push(node);
        this.connectToWcSlot(node);
      }
    }
    for (let j = 0; j < record.removedNodes.length; j++) {
      const node = record.removedNodes[j];
      if (WcSlot.isSlot(node)) {
        removed.push(node);
        this.disconnectFromWcSlot(node);
      }
    }
    for (const listener of this._slotChangeListeners) {
      listener({
        added: added.slice(),
        removed: removed.slice(),
        attributeChanged: [],
        contentChanged: []
      });
    }
  }
  connectToWcSlot(node) {
    node.emitter.addEventListener(
      "slotcontentchange",
      this.handleSlotContentChange
    );
    node.emitter.addEventListener(
      "slotattributechange",
      this.handleSlotAttributeChange
    );
  }
  disconnectFromWcSlot(node) {
    node.emitter.removeEventListener(
      "slotcontentchange",
      this.handleSlotContentChange
    );
    node.emitter.removeEventListener(
      "slotattributechange",
      this.handleSlotAttributeChange
    );
  }
  handleSlotContentChange = (event) => {
    for (const listener of this._slotChangeListeners) {
      listener({
        contentChanged: [event.detail.node],
        attributeChanged: [],
        added: [],
        removed: []
      });
    }
  };
  handleSlotAttributeChange = (event) => {
    for (const listener of this._slotChangeListeners) {
      listener({
        contentChanged: [],
        attributeChanged: [event.detail.node],
        added: [],
        removed: []
      });
    }
  };
  observeAttribute(attributeName) {
    this._observedAttributes.push(attributeName);
  }
  observeSlots(listener) {
    this._isObservingSlots = true;
    this._slotChangeListeners.push(listener);
  }
  requestUpdate() {
    if (this._isConnected) {
      this._requestBatch.request();
    }
  }
  connectedCallback() {
    this.appendChild(this._root);
    this._isConnected = true;
    this._attributeObserver.observe(this, {
      attributeFilter: this._observedAttributes,
      attributeOldValue: true,
      attributes: true,
      childList: this._isObservingSlots,
      subtree: false
    });
    this.requestUpdate();
  }
  disconnectedCallback() {
    this._isConnected = false;
    this._attributeObserver.disconnect();
    const children = Array.from(this.children);
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (WcSlot.isSlot(child)) {
        this.disconnectFromWcSlot(child);
      }
    }
    this.lifecycle.dispatchEvent(new ElementDidUnmountEvent());
  }
  /**
   * Registers a callback that will be ran on every change of the
   * specified dependencies (attribute or state) and after first
   * mount.
   *
   * This effect always happens after the DOM has been updated.
   *
   * @returns A `stop` function that cancels the effect.
   */
  effect(cb, getDependencies) {
    const deps = getDependencies(this._dependencySelector);
    let cleanup = noop;
    const runCleanup = /* @__PURE__ */ __name(() => {
      cleanup();
      cleanup = noop;
    }, "runCleanup");
    const callback = /* @__PURE__ */ __name((effect) => {
      runCleanup();
      cleanup = cb(effect) ?? noop;
    }, "callback");
    if (!deps) {
      const didMountHandler2 = /* @__PURE__ */ __name(() => {
        callback({
          isFirstMount: true
        });
      }, "didMountHandler");
      const didUpdateHandler2 = /* @__PURE__ */ __name(() => {
        callback({
          isFirstMount: false
        });
      }, "didUpdateHandler");
      this.lifecycle.once(
        "element-did-unmount" /* DidUnmount */,
        runCleanup
      );
      this.lifecycle.once(
        "element-did-mount" /* DidMount */,
        didMountHandler2
      );
      this.lifecycle.on(
        "element-did-update" /* DidUpdate */,
        didUpdateHandler2
      );
      return () => {
        this.lifecycle.off(
          "element-did-unmount" /* DidUnmount */,
          runCleanup
        );
        this.lifecycle.off(
          "element-did-mount" /* DidMount */,
          didMountHandler2
        );
        this.lifecycle.off(
          "element-did-update" /* DidUpdate */,
          didUpdateHandler2
        );
        runCleanup();
      };
    }
    if (deps.length === 0) {
      const handler = /* @__PURE__ */ __name(() => {
        callback({
          isFirstMount: true
        });
      }, "handler");
      this.lifecycle.once(
        "element-did-unmount" /* DidUnmount */,
        runCleanup
      );
      this.lifecycle.once("element-did-mount" /* DidMount */, handler);
      return () => {
        this.lifecycle.off(
          "element-did-unmount" /* DidUnmount */,
          runCleanup
        );
        this.lifecycle.off("element-did-mount" /* DidMount */, handler);
        runCleanup();
      };
    }
    const depNamesForAttr = deps.map((d) => d.name.toLowerCase());
    const depNamesForSlotOrState = deps.map((d) => d.name);
    let runCallbackOnNextUpdate = false;
    const attribChangeHandler = /* @__PURE__ */ __name((ev) => {
      if (depNamesForAttr.includes(ev.detail.attributeName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "attribChangeHandler");
    const stateChangeHandler = /* @__PURE__ */ __name((ev) => {
      if (depNamesForSlotOrState.includes(ev.detail.stateName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "stateChangeHandler");
    const slotChangeHandler = /* @__PURE__ */ __name((ev) => {
      if (depNamesForSlotOrState.includes(ev.detail.slotName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "slotChangeHandler");
    const didUpdateHandler = /* @__PURE__ */ __name(() => {
      if (runCallbackOnNextUpdate) {
        runCallbackOnNextUpdate = false;
        callback({
          isFirstMount: false
        });
      }
    }, "didUpdateHandler");
    const didMountHandler = /* @__PURE__ */ __name(() => {
      runCallbackOnNextUpdate = false;
      callback({
        isFirstMount: true
      });
    }, "didMountHandler");
    this.lifecycle.once(
      "element-did-mount" /* DidMount */,
      didMountHandler
    );
    this.lifecycle.once("element-did-unmount" /* DidUnmount */, runCleanup);
    this.lifecycle.on(
      "element-attribute-did-change" /* AttributeDidChange */,
      attribChangeHandler
    );
    this.lifecycle.on(
      "element-state-did-change" /* StateDidChange */,
      stateChangeHandler
    );
    this.lifecycle.on(
      "element-slot-did-change" /* SlotDidChange */,
      slotChangeHandler
    );
    this.lifecycle.on(
      "element-did-update" /* DidUpdate */,
      didUpdateHandler
    );
    const cancel = /* @__PURE__ */ __name(() => {
      this.lifecycle.off(
        "element-did-mount" /* DidMount */,
        didMountHandler
      );
      this.lifecycle.off(
        "element-did-unmount" /* DidUnmount */,
        runCleanup
      );
      this.lifecycle.off(
        "element-attribute-did-change" /* AttributeDidChange */,
        attribChangeHandler
      );
      this.lifecycle.off(
        "element-state-did-change" /* StateDidChange */,
        stateChangeHandler
      );
      this.lifecycle.off(
        "element-slot-did-change" /* SlotDidChange */,
        slotChangeHandler
      );
      this.lifecycle.off(
        "element-did-update" /* DidUpdate */,
        didUpdateHandler
      );
      runCleanup();
    }, "cancel");
    return cancel;
  }
  /**
   * Registers a callback that will be ran on every change of the
   * specified dependencies (attribute or state) and before first
   * mount.
   *
   * This effect always happens right before the render, meaning that
   * state and attribute changes within it will affect the subsequent
   * render result and won't trigger another re-render.
   *
   * @returns A `stop` function that cancels the effect.
   */
  immediateEffect(cb, getDependencies) {
    const deps = getDependencies(this._dependencySelector);
    let cleanup = noop;
    const runCleanup = /* @__PURE__ */ __name(() => {
      cleanup();
      cleanup = noop;
    }, "runCleanup");
    const callback = /* @__PURE__ */ __name((effect) => {
      runCleanup();
      cleanup = cb(effect) ?? noop;
    }, "callback");
    if (!deps) {
      const willMountHandler2 = /* @__PURE__ */ __name(() => {
        callback({
          isFirstMount: true
        });
      }, "willMountHandler");
      const willUpdateHandler2 = /* @__PURE__ */ __name(() => {
        callback({
          isFirstMount: false
        });
      }, "willUpdateHandler");
      this.lifecycle.once(
        "element-did-unmount" /* DidUnmount */,
        runCleanup
      );
      this.lifecycle.once(
        "element-will-mount" /* WillMount */,
        willMountHandler2
      );
      this.lifecycle.on(
        "element-will-update" /* WillUpdate */,
        willUpdateHandler2
      );
      return () => {
        this.lifecycle.off(
          "element-did-unmount" /* DidUnmount */,
          runCleanup
        );
        this.lifecycle.off(
          "element-will-mount" /* WillMount */,
          willMountHandler2
        );
        this.lifecycle.off(
          "element-will-update" /* WillUpdate */,
          willUpdateHandler2
        );
        runCleanup();
      };
    }
    if (deps.length === 0) {
      const handler = /* @__PURE__ */ __name(() => {
        callback({
          isFirstMount: true
        });
      }, "handler");
      this.lifecycle.once("element-will-mount" /* WillMount */, handler);
      return () => {
        this.lifecycle.off("element-will-mount" /* WillMount */, handler);
        runCleanup();
      };
    }
    const depNamesForAttr = deps.map((d) => d.name.toLowerCase());
    const depNamesForSlotOrState = deps.map((d) => d.name);
    let runCallbackOnNextUpdate = false;
    const attribChangeHandler = /* @__PURE__ */ __name((ev) => {
      if (depNamesForAttr.includes(ev.detail.attributeName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "attribChangeHandler");
    const stateChangeHandler = /* @__PURE__ */ __name((ev) => {
      if (depNamesForSlotOrState.includes(ev.detail.stateName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "stateChangeHandler");
    const slotChangeHandler = /* @__PURE__ */ __name((ev) => {
      if (depNamesForSlotOrState.includes(ev.detail.slotName)) {
        runCallbackOnNextUpdate = true;
      }
    }, "slotChangeHandler");
    const willUpdateHandler = /* @__PURE__ */ __name(() => {
      if (runCallbackOnNextUpdate) {
        runCallbackOnNextUpdate = false;
        callback({
          isFirstMount: false
        });
      }
    }, "willUpdateHandler");
    const willMountHandler = /* @__PURE__ */ __name(() => {
      runCallbackOnNextUpdate = false;
      callback({
        isFirstMount: true
      });
    }, "willMountHandler");
    this.lifecycle.once(
      "element-will-mount" /* WillMount */,
      willMountHandler
    );
    this.lifecycle.once("element-did-unmount" /* DidUnmount */, runCleanup);
    this.lifecycle.on(
      "element-attribute-did-change" /* AttributeDidChange */,
      attribChangeHandler
    );
    this.lifecycle.on(
      "element-state-did-change" /* StateDidChange */,
      stateChangeHandler
    );
    this.lifecycle.on(
      "element-slot-did-change" /* SlotDidChange */,
      slotChangeHandler
    );
    this.lifecycle.on(
      "element-will-update" /* WillUpdate */,
      willUpdateHandler
    );
    const cancel = /* @__PURE__ */ __name(() => {
      this.lifecycle.off(
        "element-will-mount" /* WillMount */,
        willMountHandler
      );
      this.lifecycle.off(
        "element-did-unmount" /* DidUnmount */,
        runCleanup
      );
      this.lifecycle.off(
        "element-attribute-did-change" /* AttributeDidChange */,
        attribChangeHandler
      );
      this.lifecycle.off(
        "element-state-did-change" /* StateDidChange */,
        stateChangeHandler
      );
      this.lifecycle.off(
        "element-slot-did-change" /* SlotDidChange */,
        slotChangeHandler
      );
      this.lifecycle.off(
        "element-will-update" /* WillUpdate */,
        willUpdateHandler
      );
      runCleanup();
    }, "cancel");
    return cancel;
  }
};
export {
  Attribute2 as Attribute,
  CustomElement,
  Element,
  ElementAttributeDidChangeEvent,
  ElementDidMountEvent,
  ElementDidUnmountEvent,
  ElementDidUpdateEvent,
  ElementLifecycleEvent,
  ElementSlotDidChangeEvent,
  ElementStateDidChangeEvent,
  ElementWillMountEvent,
  ElementWillUpdateEvent,
  Slotted,
  State,
  WcSlot
};
