var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/components/selector/selector.tsx
import { jsx as _jsx, jsxs as _jsxs } from "jsxte/jsx-runtime";
import { Selector } from "adwavecss";
import { Attribute, CustomElement, ElementLifecycleEvent, Slotted, State, WcSlot } from "jsxte-wc";
import { BaseElement } from "../../base-elements.mjs";
import "../../index.style.mjs";
import { cls } from "../../utils/cls.mjs";
import { CustomKeyboardEvent, CustomMouseEvent } from "../../utils/events.mjs";
import { getUid } from "../../utils/get-uid.mjs";
import { stopEvent } from "../../utils/prevent-default.mjs";
import "./selector.style.mjs";
var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function")
      throw new TypeError("Function expected");
    return f;
  }
  __name(accept, "accept");
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn)
      context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access)
      context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_ = accept(result.get))
        descriptor.get = _;
      if (_ = accept(result.set))
        descriptor.set = _;
      if (_ = accept(result.init))
        initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field")
        initializers.unshift(_);
      else
        descriptor[key] = _;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var IS_MOBILE = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
var SelectorChangeEvent = class extends CustomEvent {
  static {
    __name(this, "SelectorChangeEvent");
  }
  constructor(value) {
    super("change", {
      detail: {
        value
      }
    });
  }
};
var ADWaveSelector = (() => {
  let _classDecorators = [CustomElement("adw-selector")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _instanceExtraInitializers = [];
  let _placeholder_decorators;
  let _placeholder_initializers = [];
  let _disabled_decorators;
  let _disabled_initializers = [];
  let _name_decorators;
  let _name_initializers = [];
  let _form_decorators;
  let _form_initializers = [];
  let _orientation_decorators;
  let _orientation_initializers = [];
  let _isOpen_decorators;
  let _isOpen_initializers = [];
  let _currentOption_decorators;
  let _currentOption_initializers = [];
  let _options_decorators;
  let _options_initializers = [];
  var ADWaveSelector2 = class extends BaseElement {
    static {
      __name(this, "ADWaveSelector");
    }
    static {
      _placeholder_decorators = [Attribute({ nullable: true })];
      _disabled_decorators = [Attribute({ type: "boolean", nullable: false, default: false })];
      _name_decorators = [Attribute({ nullable: true })];
      _form_decorators = [Attribute({ nullable: true })];
      _orientation_decorators = [Attribute({ nullable: false, default: "down" })];
      _isOpen_decorators = [State()];
      _currentOption_decorators = [State()];
      _options_decorators = [Slotted({ filter: "adw-option" })];
      __esDecorate(this, null, _placeholder_decorators, { kind: "accessor", name: "placeholder", static: false, private: false, access: { has: (obj) => "placeholder" in obj, get: (obj) => obj.placeholder, set: (obj, value) => {
        obj.placeholder = value;
      } } }, _placeholder_initializers, _instanceExtraInitializers);
      __esDecorate(this, null, _disabled_decorators, { kind: "accessor", name: "disabled", static: false, private: false, access: { has: (obj) => "disabled" in obj, get: (obj) => obj.disabled, set: (obj, value) => {
        obj.disabled = value;
      } } }, _disabled_initializers, _instanceExtraInitializers);
      __esDecorate(this, null, _name_decorators, { kind: "accessor", name: "name", static: false, private: false, access: { has: (obj) => "name" in obj, get: (obj) => obj.name, set: (obj, value) => {
        obj.name = value;
      } } }, _name_initializers, _instanceExtraInitializers);
      __esDecorate(this, null, _form_decorators, { kind: "accessor", name: "form", static: false, private: false, access: { has: (obj) => "form" in obj, get: (obj) => obj.form, set: (obj, value) => {
        obj.form = value;
      } } }, _form_initializers, _instanceExtraInitializers);
      __esDecorate(this, null, _orientation_decorators, { kind: "accessor", name: "orientation", static: false, private: false, access: { has: (obj) => "orientation" in obj, get: (obj) => obj.orientation, set: (obj, value) => {
        obj.orientation = value;
      } } }, _orientation_initializers, _instanceExtraInitializers);
      __esDecorate(this, null, _isOpen_decorators, { kind: "accessor", name: "isOpen", static: false, private: false, access: { has: (obj) => "isOpen" in obj, get: (obj) => obj.isOpen, set: (obj, value) => {
        obj.isOpen = value;
      } } }, _isOpen_initializers, _instanceExtraInitializers);
      __esDecorate(this, null, _currentOption_decorators, { kind: "accessor", name: "currentOption", static: false, private: false, access: { has: (obj) => "currentOption" in obj, get: (obj) => obj.currentOption, set: (obj, value) => {
        obj.currentOption = value;
      } } }, _currentOption_initializers, _instanceExtraInitializers);
      __esDecorate(this, null, _options_decorators, { kind: "accessor", name: "options", static: false, private: false, access: { has: (obj) => "options" in obj, get: (obj) => obj.options, set: (obj, value) => {
        obj.options = value;
      } } }, _options_initializers, _instanceExtraInitializers);
      __esDecorate(null, _classDescriptor = { value: this }, _classDecorators, { kind: "class", name: this.name }, null, _classExtraInitializers);
      ADWaveSelector2 = _classThis = _classDescriptor.value;
      __runInitializers(_classThis, _classExtraInitializers);
    }
    #placeholder_accessor_storage;
    get placeholder() {
      return this.#placeholder_accessor_storage;
    }
    set placeholder(value) {
      this.#placeholder_accessor_storage = value;
    }
    #disabled_accessor_storage;
    get disabled() {
      return this.#disabled_accessor_storage;
    }
    set disabled(value) {
      this.#disabled_accessor_storage = value;
    }
    #name_accessor_storage;
    get name() {
      return this.#name_accessor_storage;
    }
    set name(value) {
      this.#name_accessor_storage = value;
    }
    #form_accessor_storage;
    get form() {
      return this.#form_accessor_storage;
    }
    set form(value) {
      this.#form_accessor_storage = value;
    }
    #orientation_accessor_storage;
    get orientation() {
      return this.#orientation_accessor_storage;
    }
    set orientation(value) {
      this.#orientation_accessor_storage = value;
    }
    #isOpen_accessor_storage;
    get isOpen() {
      return this.#isOpen_accessor_storage;
    }
    set isOpen(value) {
      this.#isOpen_accessor_storage = value;
    }
    #currentOption_accessor_storage;
    get currentOption() {
      return this.#currentOption_accessor_storage;
    }
    set currentOption(value) {
      this.#currentOption_accessor_storage = value;
    }
    #options_accessor_storage;
    get options() {
      return this.#options_accessor_storage;
    }
    set options(value) {
      this.#options_accessor_storage = value;
    }
    constructor() {
      super();
      this.#placeholder_accessor_storage = (__runInitializers(this, _instanceExtraInitializers), __runInitializers(this, _placeholder_initializers, null));
      this.#disabled_accessor_storage = __runInitializers(this, _disabled_initializers, false);
      this.#name_accessor_storage = __runInitializers(this, _name_initializers, null);
      this.#form_accessor_storage = __runInitializers(this, _form_initializers, null);
      this.#orientation_accessor_storage = __runInitializers(this, _orientation_initializers, "down");
      this.#isOpen_accessor_storage = __runInitializers(this, _isOpen_initializers, false);
      this.#currentOption_accessor_storage = __runInitializers(this, _currentOption_initializers, void 0);
      this.#options_accessor_storage = __runInitializers(this, _options_initializers, []);
      this.uid = getUid();
      this.dialogElem = { current: null };
      this.optionsListElem = { current: null };
      this.handleClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const shouldContinue = this.dispatchEvent(new CustomMouseEvent("click", {
          type: "selector"
        }, e));
        if (!shouldContinue || this.disabled) {
          return;
        }
        if (!this.isOpen) {
          this.dialogElem.current?.showModal();
          this.isOpen = true;
        } else {
          this.dialogElem.current?.close();
          this.isOpen = false;
        }
      };
      this.handleDialogClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const dialog = this.dialogElem.current;
        const shouldContinue = this.dispatchEvent(new CustomMouseEvent("click", {
          type: "dialog"
        }, e));
        if (this.isOpen && dialog && shouldContinue) {
          if (!this.optionsListElem.current?.contains(e.target)) {
            dialog.close();
            this.isOpen = false;
          }
        }
      };
      this.handleOptionClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const btn = e.target;
        const { option: optValue } = btn?.dataset ?? {};
        const shouldContinue = this.dispatchEvent(new CustomMouseEvent("click", {
          type: "option",
          option: optValue
        }, e));
        if (!shouldContinue || this.disabled || optValue == null) {
          return;
        }
        const success = this.select(optValue);
        if (success) {
          const dialog = this.dialogElem.current;
          dialog?.close();
          this.isOpen = false;
          this.focusSelf();
        }
      };
      this.handleModalCancel = (e) => {
        this.isOpen = false;
      };
      this.handleKeyDown = (ev) => {
        if (this.disabled) {
          return;
        }
        switch (ev.key) {
          case " ":
          case "Enter": {
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              if (!this.isOpen) {
                this.dialogElem.current?.showModal();
                this.isOpen = true;
              } else {
                const target = ev.target;
                if (target.tagName === "BUTTON") {
                  if (ev.key === "Enter")
                    target.click();
                } else {
                  this.dialogElem.current?.close();
                  this.isOpen = false;
                }
              }
            });
            break;
          }
          case "ArrowUp": {
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              this.focusOption(-1);
            });
            break;
          }
          case "ArrowDown": {
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              this.focusOption(1);
            });
            break;
          }
          case "PageUp": {
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              this.focusOption(-10);
            });
            break;
          }
          case "PageDown": {
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              this.focusOption(10);
            });
            break;
          }
          case "Home": {
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              this.focusOption(-this.options.length);
            });
            break;
          }
          case "End": {
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              this.focusOption(+this.options.length);
            });
            break;
          }
          case "Escape": {
            ev.preventDefault();
            this.withCustomKeyEvent(ev, () => {
              if (this.isOpen) {
                this.isOpen = false;
                this.focusSelf();
              }
            });
            break;
          }
        }
      };
      this.Option = (props) => {
        return _jsx("button", { class: Selector.option, onclick: this.handleOptionClick, "data-option": props.option.getValue(), role: "option", "aria-selected": props.option.isEqualTo(this.currentOption), children: props.option.getLabel() });
      };
      this.OptionsListMobile = () => {
        return _jsx("dialog", { ref: this.dialogElem, onclick: this.handleDialogClick, oncancel: this.handleModalCancel, children: _jsx("div", { id: this.uid, class: cls([Selector.optionsList, Selector.noPosition]), ref: this.optionsListElem, role: "listbox", children: this.options.map((option) => _jsx(this.Option, { option })) }) });
      };
      this.OptionsListDesktop = () => {
        const reverse = this.orientation === "up";
        let options = this.options;
        if (reverse) {
          options = options.toReversed();
        }
        return _jsx("div", { id: this.uid, class: cls({
          [Selector.optionsList]: true,
          [Selector.top]: reverse
        }), ref: this.optionsListElem, children: options.map((option) => _jsx(this.Option, { option })) });
      };
      this.HiddenSelect = () => {
        return _jsx("select", { class: "_adw_hidden", name: this.name ?? void 0, form: this.form ?? void 0, disabled: this.disabled ?? void 0, "aria-hidden": "true", onchange: stopEvent, children: this.options.map((option, index) => {
          return _jsx("option", { value: option.getValue(), selected: option.isEqualTo(this.currentOption) });
        }) });
      };
      this.effect(() => {
        if (this.isOpen) {
          const optionsList = this.optionsListElem.current;
          if (optionsList) {
            const reverse = this.orientation === "up";
            if (reverse) {
              optionsList.scrollTo({
                top: optionsList.scrollHeight,
                behavior: "instant"
              });
            } else {
              optionsList.scrollTo({
                top: 0,
                behavior: "instant"
              });
            }
          }
          if (!IS_MOBILE) {
            const eventHandler = /* @__PURE__ */ __name((event) => {
              if (!this.contains(event.target)) {
                this.isOpen = false;
                this.dialogElem.current?.close();
              }
            }, "eventHandler");
            document.addEventListener("click", eventHandler);
            return () => {
              document.removeEventListener("click", eventHandler);
            };
          }
        }
      }, (s) => [s.isOpen]);
      this.effect(() => {
        const firstSelected = this.options.find((opt) => opt.isSelected());
        if (firstSelected) {
          this.currentOption = firstSelected.getValue();
          for (let j = 0; j < this.options.length; j++) {
            const slot = this.options[j];
            if (slot !== firstSelected) {
              slot.setSelected(false);
            }
          }
        }
      }, () => []);
      this.lifecycle.on(ElementLifecycleEvent.SlotDidChange, (c) => {
        if (c.detail.slotName === "options") {
          let hasChanged = false;
          const changedSlots = c.detail.changes.attributeChanged;
          for (let i = 0; i < changedSlots.length; i++) {
            const slot = changedSlots[i];
            if (slot.isSelected()) {
              const newValue = slot.getValue();
              hasChanged = this.currentOption !== newValue;
              this.currentOption = newValue;
              for (let j = 0; j < this.options.length; j++) {
                const otherSlot = this.options[j];
                if (otherSlot !== slot) {
                  otherSlot.setSelected(false);
                }
              }
              break;
            }
          }
          if (hasChanged) {
            this.dispatchEvent(new SelectorChangeEvent(this.currentOption));
          }
        }
      });
    }
    focusSelf() {
      this.querySelector(`.${Selector.selector}`)?.focus();
    }
    /**
     * Selects the option that is offset from the currently focused
     * option. (e.g. focusOption(1) should select the option following
     * the currently focused one whereas focusOption(-2) should select
     * the second option that's behind the focused option)
     */
    focusOption(offset) {
      const options = this.optionsListElem.current;
      if (!options) {
        return;
      }
      const currentOption = options.querySelector(`.${Selector.option}:focus`);
      if (!currentOption) {
        if (this.isOpen) {
          const reverse = this.orientation === "up";
          const firstOption = options.querySelector(reverse ? `.${Selector.option}:last-child` : `.${Selector.option}:first-child`);
          firstOption?.focus();
        }
        return;
      }
      let target = currentOption;
      const direction = offset > 0 ? "nextElementSibling" : "previousElementSibling";
      for (let i = 0; i < Math.abs(offset); i++) {
        const next = target[direction];
        if (!next) {
          break;
        }
        target = next;
      }
      if (target) {
        target.focus();
      }
    }
    select(optionValue) {
      if (optionValue == null) {
        return false;
      }
      let success = false;
      for (let i = 0; i < this.options.length; i++) {
        const option = this.options[i];
        const isSelected = option.isEqualTo(optionValue);
        if (isSelected) {
          option.setSelected(true);
          success = true;
        }
      }
      return success;
    }
    withCustomKeyEvent(ev, cb, onCancel) {
      ev.stopPropagation();
      const shouldContinue = this.dispatchEvent(new CustomKeyboardEvent("keydown", {}, ev));
      if (shouldContinue) {
        cb();
      } else if (onCancel) {
        onCancel();
      }
    }
    getSelectedOption() {
      return this.options.find((option) => option.isEqualTo(this.currentOption));
    }
    render() {
      const label = this.getSelectedOption()?.getLabel();
      return _jsxs("div", { class: cls({
        [Selector.selector]: true,
        [Selector.opened]: this.isOpen,
        [Selector.noPosition]: IS_MOBILE,
        [Selector.disabled]: this.disabled
      }), onclick: this.handleClick, onkeydown: this.handleKeyDown, tabindex: "0", role: "combobox", "aria-haspopup": "listbox", "aria-expanded": this.isOpen, "aria-controls": this.uid, "aria-placeholder": this.placeholder, children: [_jsx("span", { class: cls({
        [Selector.selectedOption]: true,
        "with-placeholder": !label
      }), children: label ? label : this.placeholder }), _jsx("span", { class: Selector.downButton }), IS_MOBILE ? _jsx(this.OptionsListMobile, {}) : _jsx(this.OptionsListDesktop, {}), _jsx(this.HiddenSelect, {})] });
    }
  };
  return ADWaveSelector2 = _classThis;
})();
var ADWaveSelectorOption = (() => {
  let _classDecorators_1 = [CustomElement("adw-option")];
  let _classDescriptor_1;
  let _classExtraInitializers_1 = [];
  let _classThis_1;
  var ADWaveSelectorOption2 = class extends WcSlot {
    static {
      __name(this, "ADWaveSelectorOption");
    }
    static {
      __esDecorate(null, _classDescriptor_1 = { value: this }, _classDecorators_1, { kind: "class", name: this.name }, null, _classExtraInitializers_1);
      ADWaveSelectorOption2 = _classThis_1 = _classDescriptor_1.value;
      __runInitializers(_classThis_1, _classExtraInitializers_1);
    }
    get selected() {
      return this.isSelected();
    }
    set selected(selected) {
      this.setSelected(selected);
    }
    constructor() {
      super();
    }
    isEqualTo(value) {
      return this.hasValue() && this.getValue() === value;
    }
    hasValue() {
      return this.hasAttribute("value");
    }
    getValue() {
      return this.getAttribute("value") ?? "";
    }
    getLabel() {
      return this.innerText;
    }
    setSelected(selected) {
      this.setAttribute("selected", selected.toString());
    }
    isSelected() {
      return this.getAttribute("selected") === "true";
    }
    shouldEmitAttributeChangeEvent(mutations) {
      for (let i = 0; i < mutations.length; i++) {
        const mutation = mutations[i];
        if (mutation.attributeName === "selected" && mutation.oldValue !== this.getAttribute("selected")) {
          return true;
        }
      }
      return false;
    }
  };
  return ADWaveSelectorOption2 = _classThis_1;
})();
export {
  ADWaveSelector,
  ADWaveSelectorOption
};
