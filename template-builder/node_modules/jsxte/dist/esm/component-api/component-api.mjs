// src/component-api/component-api.ts
import {
  jsxElemToHtmlAsync,
  jsxElemToHtmlSync
} from "../html-renderer/jsx-elem-to-html.mjs";
import {
  jsxElemToJsonAsync,
  jsxElemToJsonSync
} from "../json-renderer/jsx-elem-to-json.mjs";
import { jsx } from "../jsx-runtime.mjs";
var ContextAccessor = class _ContextAccessor {
  constructor(map = /* @__PURE__ */ new Map()) {
    this.map = map;
  }
  static clone(original) {
    return new _ContextAccessor(new Map(original.map));
  }
  /**
   * Retrieve the context data for the specified context. If the context has
   * never been set by any of this component ancestors an error will be thrown.
   */
  getOrFail(ref) {
    const value = this.map.get(ref.id);
    if (value === void 0) {
      throw new Error(
        "Context not defined! Make sure the context is set before accessing it."
      );
    }
    return value;
  }
  /**
   * Retrieve the context data for the specified context.
   */
  get(ref) {
    const value = this.map.get(ref.id);
    return value;
  }
  /**
   * Partially update the state of the context data. Works only for objects and
   * can only be used if some context data is already set beforehand.
   *
   * Updates to the context made with this method are only visible to this
   * component and it's descendants.
   */
  update(ref, updateData) {
    const data = this.get(ref);
    if (typeof data === "object" && data !== null && typeof updateData === "object" && updateData !== null) {
      if (Array.isArray(data)) {
        const arr = Array.from(data);
        const entries = Object.entries(updateData);
        for (let i = 0; i < entries.length; i++) {
          const [key, value] = entries[i];
          const index = Number(key);
          if (!isNaN(index))
            arr[index] = value;
        }
        return void this.map.set(ref.id, arr);
      } else {
        return void this.map.set(ref.id, { ...data, ...updateData });
      }
    } else {
      throw new Error(
        "Context data is not an object!. Partial updates are only possible for objects."
      );
    }
  }
  /**
   * Sets the context data for the specified context.
   *
   * Changes to the context made with this method are only visible to this
   * component and it's descendants.
   */
  set(ref, data) {
    this.map.set(ref.id, data);
  }
  /**
   * Check if the context data for the specified context is set.
   */
  has(ref) {
    return this.map.has(ref.id);
  }
  /**
   * Replaces this context entries with the entries of the context provided.
   *
   * @internal
   */
  replace(context) {
    this.map = context.map;
  }
};
var ComponentApi = class _ComponentApi {
  constructor(attributeMap, accessor) {
    this.attributeMap = attributeMap;
    this.ctx = accessor ?? new ContextAccessor();
  }
  static create(options) {
    return new _ComponentApi(options?.attributeMap);
  }
  static clone(original) {
    return new _ComponentApi(
      original.attributeMap,
      ContextAccessor.clone(original.ctx)
    );
  }
  /**
   * Renders the given JSX component to pure html as if it was a child of this
   * component. All context available to this component will be available to the
   * given component as well.
   */
  render(component) {
    return jsxElemToHtmlSync(component, this, {
      attributeMap: this.attributeMap
    });
  }
  async renderAsync(component) {
    const thisCopy = _ComponentApi.clone(this);
    return Promise.resolve(component).then(
      (c) => jsxElemToHtmlAsync(c, thisCopy, {
        attributeMap: thisCopy.attributeMap
      })
    );
  }
  renderToJson(component) {
    return jsxElemToJsonSync(component, this, {
      attributeMap: this.attributeMap
    });
  }
  async renderToJsonAsync(component) {
    const thisCopy = _ComponentApi.clone(this);
    return Promise.resolve(component).then(
      (c) => jsxElemToJsonAsync(c, thisCopy, {
        attributeMap: thisCopy.attributeMap
      })
    );
  }
};
var ContextDefinition = class {
  constructor() {
    this.id = Symbol();
    this.Provider = (props, componentApi) => {
      componentApi.ctx.set(this, props.value);
      return jsx("", { children: props.children });
    };
    this.Consumer = (props, componentApi) => {
      const value = componentApi.ctx.get(this);
      return props.render(value);
    };
  }
};
var defineContext = () => new ContextDefinition();
export {
  ComponentApi,
  ContextAccessor,
  ContextDefinition,
  defineContext
};
