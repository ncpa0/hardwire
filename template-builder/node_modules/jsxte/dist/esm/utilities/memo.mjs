// src/utilities/memo.ts
import {
  renderToHtml,
  renderToHtmlAsync
} from "../html-renderer/render-to-html.mjs";
import { jsx, Fragment } from "../jsx-runtime.mjs";
import { Cache } from "./cache.mjs";
var ReplaceMap = (props, context) => {
  context.ctx.replace(props.context.ctx);
  return jsx(Fragment, {}, props.children);
};
var memo = (Component, options) => {
  const {
    maxCacheAge,
    maxCacheEntries,
    renderAsynchronously = false
  } = options ?? {};
  const cache = new Cache(maxCacheAge, maxCacheEntries);
  if (renderAsynchronously) {
    const MemoComponentAsync = async (props, context) => {
      const { children, ...propsNoChildren } = props;
      const cachedResult = cache.get(propsNoChildren);
      if (cachedResult)
        return cachedResult;
      const result = await renderToHtmlAsync(
        jsx(
          ReplaceMap,
          { context },
          jsx(Component, { ...propsNoChildren }, children)
        )
      );
      const textNode = {
        text: result,
        type: "textNode"
      };
      cache.set(propsNoChildren, textNode);
      return textNode;
    };
    return MemoComponentAsync;
  }
  const MemoComponent = (props, context) => {
    const { children, ...propsNoChildren } = props;
    const cachedResult = cache.get(propsNoChildren);
    if (cachedResult)
      return cachedResult;
    const result = renderToHtml(
      jsx(
        ReplaceMap,
        { context },
        jsx(Component, { ...propsNoChildren }, children)
      )
    );
    const textNode = {
      text: result,
      type: "textNode"
    };
    cache.set(propsNoChildren, textNode);
    return textNode;
  };
  return MemoComponent;
};
export {
  memo
};
