"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/jsx/jsx-runtime.ts
var jsx_runtime_exports = {};
__export(jsx_runtime_exports, {
  Fragment: () => Fragment,
  _Fragment: () => _Fragment,
  _jsx: () => _jsx,
  _jsxs: () => _jsxs,
  createElement: () => createElement,
  jsx: () => jsx,
  jsxs: () => jsxs
});
module.exports = __toCommonJS(jsx_runtime_exports);
(() => {
  if (typeof Symbol.toHtmlTag === "symbol")
    return;
  Object.defineProperty(Symbol, "toHtmlTag", {
    value: Symbol("toHtmlTag"),
    enumerable: false,
    configurable: true
  });
})();
var mapChildren = (children, accumulator) => {
  switch (typeof children) {
    case "string":
      accumulator.push({ type: "textNode", text: children });
      break;
    case "number":
      accumulator.push({ type: "textNode", text: children.toString() });
      break;
    case "object":
      if (Array.isArray(children)) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          mapChildren(child, accumulator);
        }
      } else if (children != null) {
        if (Symbol.toHtmlTag in children && typeof children[Symbol.toHtmlTag] === "function") {
          const html = String(children[Symbol.toHtmlTag]());
          accumulator.push({ type: "textNode", text: html });
        } else {
          accumulator.push(children);
        }
      }
      break;
  }
  return accumulator;
};
var createElement = (tag, props, ...children) => {
  props ?? (props = {});
  const finalChildren = [];
  for (let i = 0; i < children.length; i++) {
    mapChildren(children[i], finalChildren);
  }
  if (props?.children) {
    mapChildren(props.children, finalChildren);
  }
  props.children = finalChildren;
  Object.freeze(finalChildren);
  Object.freeze(props);
  return {
    type: "tag",
    // @ts-expect-error
    tag,
    props
  };
};
var jsx = createElement;
var jsxs = jsx;
var _jsx = jsx;
var _jsxs = jsx;
var Fragment = "";
var _Fragment = Fragment;
