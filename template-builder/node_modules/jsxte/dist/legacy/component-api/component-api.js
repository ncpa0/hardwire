"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/component-api/component-api.ts
var component_api_exports = {};
__export(component_api_exports, {
  ComponentApi: () => ComponentApi,
  ContextAccessor: () => ContextAccessor,
  ContextDefinition: () => ContextDefinition,
  defineContext: () => defineContext
});
module.exports = __toCommonJS(component_api_exports);
var import_jsx_elem_to_html = require("../html-renderer/jsx-elem-to-html.js");
var import_jsx_elem_to_json = require("../json-renderer/jsx-elem-to-json.js");
var import_jsx_runtime = require("../jsx-runtime.js");
var ContextAccessor = class _ContextAccessor {
  constructor(map = /* @__PURE__ */ new Map()) {
    this.map = map;
  }
  static clone(original) {
    return new _ContextAccessor(new Map(original.map));
  }
  /**
   * Retrieve the context data for the specified context. If the context has
   * never been set by any of this component ancestors an error will be thrown.
   */
  getOrFail(ref) {
    const value = this.map.get(ref.id);
    if (value === void 0) {
      throw new Error(
        "Context not defined! Make sure the context is set before accessing it."
      );
    }
    return value;
  }
  /**
   * Retrieve the context data for the specified context.
   */
  get(ref) {
    const value = this.map.get(ref.id);
    return value;
  }
  /**
   * Partially update the state of the context data. Works only for objects and
   * can only be used if some context data is already set beforehand.
   *
   * Updates to the context made with this method are only visible to this
   * component and it's descendants.
   */
  update(ref, updateData) {
    const data = this.get(ref);
    if (typeof data === "object" && data !== null && typeof updateData === "object" && updateData !== null) {
      if (Array.isArray(data)) {
        const arr = Array.from(data);
        const entries = Object.entries(updateData);
        for (let i = 0; i < entries.length; i++) {
          const [key, value] = entries[i];
          const index = Number(key);
          if (!isNaN(index))
            arr[index] = value;
        }
        return void this.map.set(ref.id, arr);
      } else {
        return void this.map.set(ref.id, { ...data, ...updateData });
      }
    } else {
      throw new Error(
        "Context data is not an object!. Partial updates are only possible for objects."
      );
    }
  }
  /**
   * Sets the context data for the specified context.
   *
   * Changes to the context made with this method are only visible to this
   * component and it's descendants.
   */
  set(ref, data) {
    this.map.set(ref.id, data);
  }
  /**
   * Check if the context data for the specified context is set.
   */
  has(ref) {
    return this.map.has(ref.id);
  }
  /**
   * Replaces this context entries with the entries of the context provided.
   *
   * @internal
   */
  replace(context) {
    this.map = context.map;
  }
};
var ComponentApi = class _ComponentApi {
  constructor(attributeMap, accessor) {
    this.attributeMap = attributeMap;
    this.ctx = accessor ?? new ContextAccessor();
  }
  static create(options) {
    return new _ComponentApi(options?.attributeMap);
  }
  static clone(original) {
    return new _ComponentApi(
      original.attributeMap,
      ContextAccessor.clone(original.ctx)
    );
  }
  /**
   * Renders the given JSX component to pure html as if it was a child of this
   * component. All context available to this component will be available to the
   * given component as well.
   */
  render(component) {
    return (0, import_jsx_elem_to_html.jsxElemToHtmlSync)(component, this, {
      attributeMap: this.attributeMap
    });
  }
  async renderAsync(component) {
    const thisCopy = _ComponentApi.clone(this);
    return Promise.resolve(component).then(
      (c) => (0, import_jsx_elem_to_html.jsxElemToHtmlAsync)(c, thisCopy, {
        attributeMap: thisCopy.attributeMap
      })
    );
  }
  renderToJson(component) {
    return (0, import_jsx_elem_to_json.jsxElemToJsonSync)(component, this, {
      attributeMap: this.attributeMap
    });
  }
  async renderToJsonAsync(component) {
    const thisCopy = _ComponentApi.clone(this);
    return Promise.resolve(component).then(
      (c) => (0, import_jsx_elem_to_json.jsxElemToJsonAsync)(c, thisCopy, {
        attributeMap: thisCopy.attributeMap
      })
    );
  }
};
var ContextDefinition = class {
  constructor() {
    this.id = Symbol();
    this.Provider = (props, componentApi) => {
      componentApi.ctx.set(this, props.value);
      return (0, import_jsx_runtime.jsx)("", { children: props.children });
    };
    this.Consumer = (props, componentApi) => {
      const value = componentApi.ctx.get(this);
      return props.render(value);
    };
  }
};
var defineContext = () => new ContextDefinition();
