"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utilities/memo.ts
var memo_exports = {};
__export(memo_exports, {
  memo: () => memo
});
module.exports = __toCommonJS(memo_exports);
var import_render_to_html = require("../html-renderer/render-to-html.cjs");
var import_jsx_runtime = require("../jsx-runtime.cjs");
var import_cache = require("./cache.cjs");
var ReplaceMap = (props, context) => {
  context.ctx.replace(props.context.ctx);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {}, props.children);
};
var memo = (Component, options) => {
  const {
    maxCacheAge,
    maxCacheEntries,
    renderAsynchronously = false
  } = options ?? {};
  const cache = new import_cache.Cache(maxCacheAge, maxCacheEntries);
  if (renderAsynchronously) {
    const MemoComponentAsync = async (props, context) => {
      const { children, ...propsNoChildren } = props;
      const cachedResult = cache.get(propsNoChildren);
      if (cachedResult)
        return cachedResult;
      const result = await (0, import_render_to_html.renderToHtmlAsync)(
        (0, import_jsx_runtime.jsx)(
          ReplaceMap,
          { context },
          (0, import_jsx_runtime.jsx)(Component, { ...propsNoChildren }, children)
        )
      );
      const textNode = {
        text: result,
        type: "textNode"
      };
      cache.set(propsNoChildren, textNode);
      return textNode;
    };
    return MemoComponentAsync;
  }
  const MemoComponent = (props, context) => {
    const { children, ...propsNoChildren } = props;
    const cachedResult = cache.get(propsNoChildren);
    if (cachedResult)
      return cachedResult;
    const result = (0, import_render_to_html.renderToHtml)(
      (0, import_jsx_runtime.jsx)(
        ReplaceMap,
        { context },
        (0, import_jsx_runtime.jsx)(Component, { ...propsNoChildren }, children)
      )
    );
    const textNode = {
      text: result,
      type: "textNode"
    };
    cache.set(propsNoChildren, textNode);
    return textNode;
  };
  return MemoComponent;
};
